
## 表排序

  对于大的待排元素的排序, 因为挪动大文件的时间不可忽略, 所以不能直接交换排序

  创建一个中间表, 指向元素的指针依次放到表中, 并将其下标放入对应的 table 中

  每次排序的时候, 比较文件的内容 key , 之后交换的是 table 既下标 , 而不改变文件的位置 

  每次要顺序读取的时候就按照下标读取出实际在这个序号的文件下标

> 下图中, A 行为下标, table 行为元素在表中的下标, key 行为文件内容

![image-20210324162010795](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210324162010795-1616574010938.png)

## 物理排序

  如果非要把元素按照顺序存放, 就要更改实际的物理顺序

  下面的方法可以以 T = O(复制文件的时间 time * n) 的复杂度完成

![image-20210324161608554](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210324161608554-1616573768751.png)

图中有三个环

- a, b, d, f 

- c
- g, h, e

移动空间示例:

> 把 a 拿出来
>
> 把 A[3].key 放到 A[0].key, 改变 table 为 0
>
> 把 A[1].key 放到 A[3].key , 改变 table 为 3
>
> ... 
>
> 直到 要把 A[0].key 放入其他位置
>
> 这个环中的元素按照正确的位置放入
>
> 对于其他的环也一样

