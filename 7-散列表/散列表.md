

## 散列表

### 定义 : 
每个 key 对应一个 value

每次获取 key, 带入散列函数 h(key) 运算得到下标

数组的相应的下标位置放 value

装填因子 = 表中元素 / 表大小

### 散列函数的构造方法 : 
(虽然函数要求输入的是数字, 但是 key实际可以为字符串, 因为字符串可以用二进制表示)

- 直接定址法

    h(key) = a * key + b (a, b 为常数)

- 除留余数法

    h(key) = key mod p (p 一般去素数)

- 数字分析法

    h(key) = atoi(key+n) (取 key 中特殊的几位字符转换成数字 ) 

- 折叠法

    key 分割成位数相同的数, 加起来就是下标

- 平方取中法

    取 key 平方中间的几位数作为下标

### 如何解决冲突 : 
(key 带入哈希函数运算之后算出一样的值如何处理)

#### 开放定址法
出现冲突时, 换一个地址
hi = (h(key)+di) mod TableSize 
(i 代表 第 i 次冲突, mod 取余使得其不会超出边界)

1. 线性探测
   
    di = i, 变换的地址随着冲突次数增加

    d1 = 1, d2 = 2, d3 = 3 ... di = tableSize - 1

    > 例子 : 
    >       h0 = 3 
    >       出现冲突 第一次 , h1 = (h0 + 1) mod tableSize
    >       又有冲突 第二次, h2 = (h0 + 2) mod tableSize
    >       继续冲突 第三次, h3 = (h0 + 3) mod tableSize
    >       ...




2. 平方探测
    di = (±)i^2, 变换的地址随着冲突次数增加

    d1 = (+)1^2, d2 = (-)1^2, d3 = (+)2^2, d4 = (-)2^2  ...

    >   例子 : 
    >    h0 = 3 
    >    出现冲突 第一次 , h1 = (h0 + 1) mod tableSize
    >    又有冲突 第二次, h2 = (h0 - 1) mod tableSize
    >    继续冲突 第三次, h3 = (h0 + 2^2) mod tableSize
    >    继续冲突 第四次, h4 = (h0 - 2^2) mod tableSize
    >    ...

3. 双散列探测法

    di = i * h2(key) , h2(key)是另一个散列函数

    d1 = h2(key), d2 = 2 * h2(key), d3 = 3 * h2(key) ...

4. 再散列

    装填因子过大, 创建新的散列表后放进去

#### 分离链接法
    将位置冲突的 key 存储在同一个单链表中
